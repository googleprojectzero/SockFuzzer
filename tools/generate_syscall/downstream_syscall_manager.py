# Copyright 2024 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Codegen is messy. And it's made messier by the number of edge cases and
exceptions in how bsd syscalls are named/typed/formatted/etc.

generate_wrappers.py takes care of a few edge cases. At this point, we
need to generate protobufs for each syscall, and code that converts the
protobuf into arguments and calls the syscall wrapper. That's what happens
in this file.

Syscalls do not have meaningful type information. We require manually
typing the arguments in syscalls.defs. This uses a custom grammar
(somewhat inspired by syzlang). Types are defined in syscall_fields.py.

To add more syscalls, you will hopefully only need to touch syscalls.defs
and syscall_fields.py.
"""
import textwrap
import io
import sys

from tools.generate_syscall.downstream_syscall import DownstreamSyscall
from tools.generate_syscall.upstream_syscall_manager import UpstreamSyscallManager


class DownstreamSyscallManager:
    """
    Container for all syscalls
    """

    def __init__(self, syscalls):
        self.syscalls = syscalls

    @classmethod
    def from_defs(cls, path):
        syscalls = []
        with open(path, "r") as syscall_defs:
            for line in syscall_defs:
                line = line.strip()
                if len(line) == 0 or line.startswith("#"):
                    continue
                syscall = DownstreamSyscall.from_line(line)
                syscalls.append(syscall)
        print(f"Parsed {len(syscalls)} syscalls from {path}")
        print("Parsed syscalls:", [syscall.name for syscall in syscalls])
        return cls(syscalls)

    def write_protos(self, upstream_syscall_manager, out: io.TextIOBase):
        preamble = """\
        // Autogenerated by generate.sh

        syntax = "proto2";

        import "fuzz/proto/bsd_types.proto";
        import "fuzz/proto/bsd_enums.proto";

        """
        fields = ""
        output = textwrap.dedent(preamble)

        upstream_syscalls = {}
        missing_syscalls = []
        for syscall in self.syscalls:
            upstream_syscall = upstream_syscall_manager.find(syscall.name)
            if upstream_syscall is None:
                missing_syscalls.append(syscall.name)
            else:
                upstream_syscalls[syscall.name] = upstream_syscall

        if missing_syscalls:
            print(f"\nError: {len(missing_syscalls)} syscalls not found in upstream_syscalls:")
            for name in missing_syscalls:
                print(f"  {name}")
            print(f"\nTotal downstream syscalls: {len(self.syscalls)}")
            print(f"Total upstream syscalls: {len(upstream_syscall_manager.syscalls)}")
            raise ValueError(f"Couldn't find {len(missing_syscalls)} syscalls in upstream_syscalls")

        syscalls = sorted(
            self.syscalls, key=lambda syscall: upstream_syscalls[syscall.name].number
        )
        for i, syscall in enumerate(syscalls):
            try:
                output += syscall.proto_message + "\n"
                # TODO(nedwill): set i using syscalls.name
                fields += f"{syscall.proto_syscall_field} = {upstream_syscalls[syscall.name].number};"
                if i + 1 < len(syscalls):
                    fields += "\n"
            except Exception as exc:
                raise ValueError(
                    f"Error while generating protos of '{syscall.name}'"
                ) from exc

        fields = textwrap.indent(fields, "            ")
        syscalls = """\
        message BsdSyscall {{
          oneof syscall {{\n{fields}
          }}
        }}
        """.format(
            fields=fields
        )
        output += textwrap.dedent(syscalls)

        out.write(output)

    def write_caller(self, out):
        preamble = """\
        // Autogenerated by generate.sh

        #include "tools/generate_syscall/call_bsd_syscall.h"

        #include "fuzz/handlers/bsd_types.h"
        #include "tools/generate_syscall/syscall_wrappers_generated.h"

        void CallBsdSyscall(const BsdSyscall &syscall) {
        switch (syscall.syscall_case()) {
        """
        output = textwrap.dedent(preamble)
        for syscall in self.syscalls:
            try:
                output += textwrap.indent(syscall.calling_code, "    ")
            except:
                raise ValueError(f"Error while generating caller of '{syscall.name}'")
        output += "default:\n"
        output += "  break;"
        output += "  }\n}"
        out.write(output)


if __name__ == "__main__":

    import argparse

    parser = argparse.ArgumentParser(description="Codegen based on syscalls.defs")
    parser.add_argument(
        "-i",
        dest="input",
        required=True,
        metavar="FILE",
        help="Path to syscalls.defs",
    )
    parser.add_argument(
        "-u",
        dest="upstream_input",
        required=True,
        metavar="FILE",
        help="Path to syscalls.master",
    )
    parser.add_argument(
        "-D",
        dest="flags",
        action="append",
        help="Define a compiler flag for filtering syscalls.",
    )
    parser.add_argument(
        "--protos", dest="protos", metavar="FILE", help="Path to save protos"
    )
    parser.add_argument(
        "--caller",
        dest="caller",
        metavar="FILE",
        help="Path to save calling code",
    )
    args = parser.parse_args()

    upstream_syscalls = UpstreamSyscallManager.from_path(
        args.upstream_input, args.flags, []
    )
    if upstream_syscalls is None:
        print(f"Failed to parse {args.upstream_input}")
        sys.exit(1)

    syscalls = DownstreamSyscallManager.from_defs(args.input)
    if syscalls is None:
        print(f"Failed to parse {args.input}")
        sys.exit(1)

    if args.protos:
        with open(args.protos, "w") as out:
            syscalls.write_protos(upstream_syscalls, out)

    if args.caller:
        with open(args.caller, "w") as out:
            syscalls.write_caller(out)
